/**
 * Generated by orval v6.27.1 üç∫
 * Do not edit manually.
 * Vscubing Api
 * vscubing Api
 * OpenAPI spec version: 0.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'
import type {
  ContestsContestListOutput,
  ContestsContestsLeaderboardRetrieveParams,
  ContestsContestsRetrieveParams,
  ContestsRoundSessionWithSolvesListOutput,
  ContestsSingleResultLeaderboardOutput,
  ContestsSolveRetrieveOutput,
  ContestsSolvesSingleResultLeaderboardRetrieveParams,
  Input,
  OngoingContestRetrieve,
  SocialLogin,
  TokenRefresh,
  User,
} from './vscubingApi.schemas'
import { axiosInstance } from '../lib/orval.axiosInstance'
import type { ErrorType } from '../lib/orval.axiosInstance'

type IsAny<T> = 0 extends 1 & T ? true : false
type IsUnknown<T> = IsAny<T> extends true ? false : unknown extends T ? true : false
type Primitive = string | number | boolean | bigint | symbol | undefined | null
type isBuiltin = Primitive | Function | Date | Error | RegExp
type NonReadonly<T> = T extends Exclude<isBuiltin, Error>
  ? T
  : T extends Map<infer Key, infer Value>
    ? Map<NonReadonly<Key>, NonReadonly<Value>>
    : T extends ReadonlyMap<infer Key, infer Value>
      ? Map<NonReadonly<Key>, NonReadonly<Value>>
      : T extends WeakMap<infer Key, infer Value>
        ? WeakMap<NonReadonly<Key>, NonReadonly<Value>>
        : T extends Set<infer Values>
          ? Set<NonReadonly<Values>>
          : T extends ReadonlySet<infer Values>
            ? Set<NonReadonly<Values>>
            : T extends WeakSet<infer Values>
              ? WeakSet<NonReadonly<Values>>
              : T extends Promise<infer Value>
                ? Promise<NonReadonly<Value>>
                : T extends {}
                  ? { -readonly [Key in keyof T]: NonReadonly<T[Key]> }
                  : IsUnknown<T> extends true
                    ? unknown
                    : T

export const accountsChangeUsernameUpdate = (input: NonReadonly<Input>) => {
  const formUrlEncoded = new URLSearchParams()
  formUrlEncoded.append('id', input.id.toString())
  formUrlEncoded.append('username', input.username)

  return axiosInstance<User>({
    url: `/api/accounts/change-username/`,
    method: 'PUT',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    data: formUrlEncoded,
  })
}

export const getAccountsChangeUsernameUpdateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof accountsChangeUsernameUpdate>>,
    TError,
    { data: NonReadonly<Input> },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof accountsChangeUsernameUpdate>>,
  TError,
  { data: NonReadonly<Input> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof accountsChangeUsernameUpdate>>,
    { data: NonReadonly<Input> }
  > = (props) => {
    const { data } = props ?? {}

    return accountsChangeUsernameUpdate(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type AccountsChangeUsernameUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof accountsChangeUsernameUpdate>>
>
export type AccountsChangeUsernameUpdateMutationBody = NonReadonly<Input>
export type AccountsChangeUsernameUpdateMutationError = ErrorType<unknown>

export const useAccountsChangeUsernameUpdate = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof accountsChangeUsernameUpdate>>,
    TError,
    { data: NonReadonly<Input> },
    TContext
  >
}): UseMutationResult<
  Awaited<ReturnType<typeof accountsChangeUsernameUpdate>>,
  TError,
  { data: NonReadonly<Input> },
  TContext
> => {
  const mutationOptions = getAccountsChangeUsernameUpdateMutationOptions(options)

  return useMutation(mutationOptions)
}

export const accountsCurrentUserRetrieve = (signal?: AbortSignal) => {
  return axiosInstance<void>({ url: `/api/accounts/current-user/`, method: 'GET', signal })
}

export const getAccountsCurrentUserRetrieveQueryKey = () => {
  return [`/api/accounts/current-user/`] as const
}

export const getAccountsCurrentUserRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof accountsCurrentUserRetrieve>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof accountsCurrentUserRetrieve>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAccountsCurrentUserRetrieveQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof accountsCurrentUserRetrieve>>> = ({ signal }) =>
    accountsCurrentUserRetrieve(signal)

  return {
    queryKey,
    queryFn,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
    staleTime: Infinity,
    retry: (_, err) => {
      var _a, _b, _c, _d
      return (
        ((_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status) !== 403 &&
        ((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.status) !== 401 &&
        ((_c = err == null ? void 0 : err.response) == null ? void 0 : _c.status) !== 404 &&
        ((_d = err == null ? void 0 : err.response) == null ? void 0 : _d.status) !== 400
      )
    },
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof accountsCurrentUserRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type AccountsCurrentUserRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof accountsCurrentUserRetrieve>>
>
export type AccountsCurrentUserRetrieveQueryError = ErrorType<unknown>

export const useAccountsCurrentUserRetrieve = <
  TData = Awaited<ReturnType<typeof accountsCurrentUserRetrieve>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof accountsCurrentUserRetrieve>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getAccountsCurrentUserRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * class used for social authentications
example usage for facebook with access_token
-------------
from allauth.socialaccount.providers.facebook.views import FacebookOAuth2Adapter

class FacebookLogin(SocialLoginView):
    adapter_class = FacebookOAuth2Adapter
-------------

example usage for facebook with code

-------------
from allauth.socialaccount.providers.facebook.views import FacebookOAuth2Adapter
from allauth.socialaccount.providers.oauth2.client import OAuth2Client

class FacebookLogin(SocialLoginView):
    adapter_class = FacebookOAuth2Adapter
    client_class = OAuth2Client
    callback_url = 'localhost:8000'
-------------
 */
export const accountsGoogleLoginCreate = (socialLogin: SocialLogin) => {
  const formUrlEncoded = new URLSearchParams()
  if (socialLogin.accessToken !== undefined) {
    formUrlEncoded.append('accessToken', socialLogin.accessToken)
  }
  if (socialLogin.code !== undefined) {
    formUrlEncoded.append('code', socialLogin.code)
  }
  if (socialLogin.idToken !== undefined) {
    formUrlEncoded.append('idToken', socialLogin.idToken)
  }

  return axiosInstance<SocialLogin>({
    url: `/api/accounts/google/login/`,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    data: formUrlEncoded,
  })
}

export const getAccountsGoogleLoginCreateMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof accountsGoogleLoginCreate>>,
    TError,
    { data: SocialLogin },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof accountsGoogleLoginCreate>>,
  TError,
  { data: SocialLogin },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof accountsGoogleLoginCreate>>, { data: SocialLogin }> = (
    props,
  ) => {
    const { data } = props ?? {}

    return accountsGoogleLoginCreate(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type AccountsGoogleLoginCreateMutationResult = NonNullable<Awaited<ReturnType<typeof accountsGoogleLoginCreate>>>
export type AccountsGoogleLoginCreateMutationBody = SocialLogin
export type AccountsGoogleLoginCreateMutationError = ErrorType<unknown>

export const useAccountsGoogleLoginCreate = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof accountsGoogleLoginCreate>>,
    TError,
    { data: SocialLogin },
    TContext
  >
}): UseMutationResult<
  Awaited<ReturnType<typeof accountsGoogleLoginCreate>>,
  TError,
  { data: SocialLogin },
  TContext
> => {
  const mutationOptions = getAccountsGoogleLoginCreateMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Takes a refresh type JSON web token and returns an access type JSON web
token if the refresh token is valid.
 */
export const accountsTokenRefreshCreate = (tokenRefresh: NonReadonly<TokenRefresh>) => {
  const formUrlEncoded = new URLSearchParams()
  formUrlEncoded.append('access', tokenRefresh.access)
  formUrlEncoded.append('refresh', tokenRefresh.refresh)

  return axiosInstance<TokenRefresh>({
    url: `/api/accounts/token/refresh/`,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    data: formUrlEncoded,
  })
}

export const getAccountsTokenRefreshCreateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof accountsTokenRefreshCreate>>,
    TError,
    { data: NonReadonly<TokenRefresh> },
    TContext
  >
}): UseMutationOptions<
  Awaited<ReturnType<typeof accountsTokenRefreshCreate>>,
  TError,
  { data: NonReadonly<TokenRefresh> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof accountsTokenRefreshCreate>>,
    { data: NonReadonly<TokenRefresh> }
  > = (props) => {
    const { data } = props ?? {}

    return accountsTokenRefreshCreate(data)
  }

  return { mutationFn, ...mutationOptions }
}

export type AccountsTokenRefreshCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof accountsTokenRefreshCreate>>
>
export type AccountsTokenRefreshCreateMutationBody = NonReadonly<TokenRefresh>
export type AccountsTokenRefreshCreateMutationError = ErrorType<unknown>

export const useAccountsTokenRefreshCreate = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof accountsTokenRefreshCreate>>,
    TError,
    { data: NonReadonly<TokenRefresh> },
    TContext
  >
}): UseMutationResult<
  Awaited<ReturnType<typeof accountsTokenRefreshCreate>>,
  TError,
  { data: NonReadonly<TokenRefresh> },
  TContext
> => {
  const mutationOptions = getAccountsTokenRefreshCreateMutationOptions(options)

  return useMutation(mutationOptions)
}

export const contestsContestsRetrieve = (params?: ContestsContestsRetrieveParams, signal?: AbortSignal) => {
  return axiosInstance<ContestsContestListOutput>({ url: `/api/contests/contests/`, method: 'GET', params, signal })
}

export const getContestsContestsRetrieveQueryKey = (params?: ContestsContestsRetrieveParams) => {
  return [`/api/contests/contests/`, ...(params ? [params] : [])] as const
}

export const getContestsContestsRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof contestsContestsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  params?: ContestsContestsRetrieveParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof contestsContestsRetrieve>>, TError, TData>> },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getContestsContestsRetrieveQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof contestsContestsRetrieve>>> = ({ signal }) =>
    contestsContestsRetrieve(params, signal)

  return {
    queryKey,
    queryFn,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
    staleTime: Infinity,
    retry: (_, err) => {
      var _a, _b, _c, _d
      return (
        ((_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status) !== 403 &&
        ((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.status) !== 401 &&
        ((_c = err == null ? void 0 : err.response) == null ? void 0 : _c.status) !== 404 &&
        ((_d = err == null ? void 0 : err.response) == null ? void 0 : _d.status) !== 400
      )
    },
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof contestsContestsRetrieve>>, TError, TData> & { queryKey: QueryKey }
}

export type ContestsContestsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof contestsContestsRetrieve>>>
export type ContestsContestsRetrieveQueryError = ErrorType<unknown>

export const useContestsContestsRetrieve = <
  TData = Awaited<ReturnType<typeof contestsContestsRetrieve>>,
  TError = ErrorType<unknown>,
>(
  params?: ContestsContestsRetrieveParams,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof contestsContestsRetrieve>>, TError, TData>> },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getContestsContestsRetrieveQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const contestsContestsLeaderboardRetrieve = (
  contestSlug: string,
  params: ContestsContestsLeaderboardRetrieveParams,
  signal?: AbortSignal,
) => {
  return axiosInstance<ContestsRoundSessionWithSolvesListOutput>({
    url: `/api/contests/contests/${contestSlug}/leaderboard/`,
    method: 'GET',
    params,
    signal,
  })
}

export const getContestsContestsLeaderboardRetrieveQueryKey = (
  contestSlug: string,
  params: ContestsContestsLeaderboardRetrieveParams,
) => {
  return [`/api/contests/contests/${contestSlug}/leaderboard/`, ...(params ? [params] : [])] as const
}

export const getContestsContestsLeaderboardRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof contestsContestsLeaderboardRetrieve>>,
  TError = ErrorType<unknown>,
>(
  contestSlug: string,
  params: ContestsContestsLeaderboardRetrieveParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof contestsContestsLeaderboardRetrieve>>, TError, TData>>
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getContestsContestsLeaderboardRetrieveQueryKey(contestSlug, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof contestsContestsLeaderboardRetrieve>>> = ({ signal }) =>
    contestsContestsLeaderboardRetrieve(contestSlug, params, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!contestSlug,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
    staleTime: Infinity,
    retry: (_, err) => {
      var _a, _b, _c, _d
      return (
        ((_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status) !== 403 &&
        ((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.status) !== 401 &&
        ((_c = err == null ? void 0 : err.response) == null ? void 0 : _c.status) !== 404 &&
        ((_d = err == null ? void 0 : err.response) == null ? void 0 : _d.status) !== 400
      )
    },
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof contestsContestsLeaderboardRetrieve>>, TError, TData> & {
    queryKey: QueryKey
  }
}

export type ContestsContestsLeaderboardRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof contestsContestsLeaderboardRetrieve>>
>
export type ContestsContestsLeaderboardRetrieveQueryError = ErrorType<unknown>

export const useContestsContestsLeaderboardRetrieve = <
  TData = Awaited<ReturnType<typeof contestsContestsLeaderboardRetrieve>>,
  TError = ErrorType<unknown>,
>(
  contestSlug: string,
  params: ContestsContestsLeaderboardRetrieveParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof contestsContestsLeaderboardRetrieve>>, TError, TData>>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getContestsContestsLeaderboardRetrieveQueryOptions(contestSlug, params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const contestsOngoingContestRetrieveRetrieve = (signal?: AbortSignal) => {
  return axiosInstance<OngoingContestRetrieve>({
    url: `/api/contests/ongoing-contest/retrieve/`,
    method: 'GET',
    signal,
  })
}

export const getContestsOngoingContestRetrieveRetrieveQueryKey = () => {
  return [`/api/contests/ongoing-contest/retrieve/`] as const
}

export const getContestsOngoingContestRetrieveRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof contestsOngoingContestRetrieveRetrieve>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof contestsOngoingContestRetrieveRetrieve>>, TError, TData>>
}) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getContestsOngoingContestRetrieveRetrieveQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof contestsOngoingContestRetrieveRetrieve>>> = ({ signal }) =>
    contestsOngoingContestRetrieveRetrieve(signal)

  return {
    queryKey,
    queryFn,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
    staleTime: Infinity,
    retry: (_, err) => {
      var _a, _b, _c, _d
      return (
        ((_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status) !== 403 &&
        ((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.status) !== 401 &&
        ((_c = err == null ? void 0 : err.response) == null ? void 0 : _c.status) !== 404 &&
        ((_d = err == null ? void 0 : err.response) == null ? void 0 : _d.status) !== 400
      )
    },
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof contestsOngoingContestRetrieveRetrieve>>, TError, TData> & {
    queryKey: QueryKey
  }
}

export type ContestsOngoingContestRetrieveRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof contestsOngoingContestRetrieveRetrieve>>
>
export type ContestsOngoingContestRetrieveRetrieveQueryError = ErrorType<unknown>

export const useContestsOngoingContestRetrieveRetrieve = <
  TData = Awaited<ReturnType<typeof contestsOngoingContestRetrieveRetrieve>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof contestsOngoingContestRetrieveRetrieve>>, TError, TData>>
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getContestsOngoingContestRetrieveRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const contestsSolvesRetrieveRetrieve = (id: number, signal?: AbortSignal) => {
  return axiosInstance<ContestsSolveRetrieveOutput>({
    url: `/api/contests/solves/${id}/retrieve/`,
    method: 'GET',
    signal,
  })
}

export const getContestsSolvesRetrieveRetrieveQueryKey = (id: number) => {
  return [`/api/contests/solves/${id}/retrieve/`] as const
}

export const getContestsSolvesRetrieveRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof contestsSolvesRetrieveRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof contestsSolvesRetrieveRetrieve>>, TError, TData>>
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getContestsSolvesRetrieveRetrieveQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof contestsSolvesRetrieveRetrieve>>> = ({ signal }) =>
    contestsSolvesRetrieveRetrieve(id, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
    staleTime: Infinity,
    retry: (_, err) => {
      var _a, _b, _c, _d
      return (
        ((_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status) !== 403 &&
        ((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.status) !== 401 &&
        ((_c = err == null ? void 0 : err.response) == null ? void 0 : _c.status) !== 404 &&
        ((_d = err == null ? void 0 : err.response) == null ? void 0 : _d.status) !== 400
      )
    },
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof contestsSolvesRetrieveRetrieve>>, TError, TData> & {
    queryKey: QueryKey
  }
}

export type ContestsSolvesRetrieveRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof contestsSolvesRetrieveRetrieve>>
>
export type ContestsSolvesRetrieveRetrieveQueryError = ErrorType<unknown>

export const useContestsSolvesRetrieveRetrieve = <
  TData = Awaited<ReturnType<typeof contestsSolvesRetrieveRetrieve>>,
  TError = ErrorType<unknown>,
>(
  id: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof contestsSolvesRetrieveRetrieve>>, TError, TData>>
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getContestsSolvesRetrieveRetrieveQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}

export const contestsSolvesSingleResultLeaderboardRetrieve = (
  params?: ContestsSolvesSingleResultLeaderboardRetrieveParams,
  signal?: AbortSignal,
) => {
  return axiosInstance<ContestsSingleResultLeaderboardOutput>({
    url: `/api/contests/solves/single-result-leaderboard`,
    method: 'GET',
    params,
    signal,
  })
}

export const getContestsSolvesSingleResultLeaderboardRetrieveQueryKey = (
  params?: ContestsSolvesSingleResultLeaderboardRetrieveParams,
) => {
  return [`/api/contests/solves/single-result-leaderboard`, ...(params ? [params] : [])] as const
}

export const getContestsSolvesSingleResultLeaderboardRetrieveQueryOptions = <
  TData = Awaited<ReturnType<typeof contestsSolvesSingleResultLeaderboardRetrieve>>,
  TError = ErrorType<unknown>,
>(
  params?: ContestsSolvesSingleResultLeaderboardRetrieveParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof contestsSolvesSingleResultLeaderboardRetrieve>>, TError, TData>
    >
  },
) => {
  const { query: queryOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getContestsSolvesSingleResultLeaderboardRetrieveQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof contestsSolvesSingleResultLeaderboardRetrieve>>> = ({
    signal,
  }) => contestsSolvesSingleResultLeaderboardRetrieve(params, signal)

  return {
    queryKey,
    queryFn,
    refetchOnWindowFocus: false,
    refetchOnMount: false,
    staleTime: Infinity,
    retry: (_, err) => {
      var _a, _b, _c, _d
      return (
        ((_a = err == null ? void 0 : err.response) == null ? void 0 : _a.status) !== 403 &&
        ((_b = err == null ? void 0 : err.response) == null ? void 0 : _b.status) !== 401 &&
        ((_c = err == null ? void 0 : err.response) == null ? void 0 : _c.status) !== 404 &&
        ((_d = err == null ? void 0 : err.response) == null ? void 0 : _d.status) !== 400
      )
    },
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof contestsSolvesSingleResultLeaderboardRetrieve>>, TError, TData> & {
    queryKey: QueryKey
  }
}

export type ContestsSolvesSingleResultLeaderboardRetrieveQueryResult = NonNullable<
  Awaited<ReturnType<typeof contestsSolvesSingleResultLeaderboardRetrieve>>
>
export type ContestsSolvesSingleResultLeaderboardRetrieveQueryError = ErrorType<unknown>

export const useContestsSolvesSingleResultLeaderboardRetrieve = <
  TData = Awaited<ReturnType<typeof contestsSolvesSingleResultLeaderboardRetrieve>>,
  TError = ErrorType<unknown>,
>(
  params?: ContestsSolvesSingleResultLeaderboardRetrieveParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof contestsSolvesSingleResultLeaderboardRetrieve>>, TError, TData>
    >
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getContestsSolvesSingleResultLeaderboardRetrieveQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey }

  query.queryKey = queryOptions.queryKey

  return query
}
